const requiresString = "Validation input must be a string"

/**
 * Validates that an input is present
 *
 * @param input
 * @returns {string} The error message(s) generated by the validation
 */
export function required(input: unknown): string {
	const fail = "Required"

	if (input === null || input === undefined || input === false) {
		return fail
	}

	if (Array.isArray(input) && input.length === 0) {
		return fail
	}

	if (typeof input === "object" && Object.keys(input).length === 0) {
		return fail
	}

	if (input === 0)
		return

	if (!input) {
		return fail
	}

	if (typeof input === "string" && !input.trim()) {
		return fail
	}
}

/**
 * Validates that an input is between two lengths (inclusive)
 *
 * This validator must be passed into the validators prop in a wrapper function because of the min and max variables.
 *
 * @example
 * const min = 6, max = 32
 * <TextInput
 *   {...props}
 *   validators={[(input) => requireLength(input, min, max)]}
 * />
 *
 * @param {string} input The string to test
 * @param {number} min The minimum allowed length
 * @param {number} max The maximum allowed length
 * @returns {string} The error message(s) generated by the validation
 */
export function requireLength(input: string, min: number, max: number): string {
	if (typeof input !== "string") {
		throw new TypeError(requiresString)
	}

	if (typeof min !== "number" || typeof max !== "number") {
		throw new TypeError("min and max options must both be numbers")
	}

	if (input.length < min || input.length > max) {
		return `Must be between ${min} and ${max} characters`
	}
}

/**
 * Validates that an input contains an uppercase letter
 *
 * @param {string} input The string to test
 * @returns {string} The error message(s) generated by the validation
 */
export function requireUpperCase(input: string): string {
	if (typeof input !== "string") {
		throw new TypeError(requiresString)
	}

	if (!input.match(/[A-Z]/)) {
		return "Must contain an uppercase letter"
	}
}

/**
 * Validates that an input contains a lowercase letter
 *
 * @param {string} input The string to test
 * @returns {string} The error message(s) generated by the validation
 */
export function requireLowerCase(input: string): string {
	if (typeof input !== "string") {
		throw new TypeError(requiresString)
	}

	if (!input.match(/[a-z]/)) {
		return "Must contain a lowercase letter"
	}
}

/**
 * Validates that an input contains a number
 *
 * @param {string} input The string to test
 * @returns {string} The error message(s) generated by the validation
 */
export function requireDigit(input: string): string {
	if (typeof input !== "string") {
		throw new TypeError(requiresString)
	}

	if (!input.match(/\d/)) {
		return "Must contain a number"
	}
}

/**
 * Validates that a string contains no special characters
 *
 * @param {string} input The string to validate
 * @returns {string} The error message(s) generated by the validation
 */
export function requireNoSpecialChar(input: string): string {
	if (typeof input !== "string") {
		throw new TypeError(requiresString)
	}

	if (input.match(/\W/)) {
		return "Must contain only letters, numbers, and underscores"
	}
}

/**
 * Validates that a string contains a special character
 *
 * @param {string} input The string to validate
 * @returns {string|undefined} The error message(s) generated by the validation
 */
export function requireSpecialChar(input: string): string {
	if (typeof input !== "string") {
		throw new TypeError(requiresString)
	}

	if (!input.match(/[^A-Za-z0-9]/)) {
		return "Must contain at least one special character"
	}
}

/**
 * Validates that two values are the same
 *
 * This validator uses '===' to test for equality, so it will fail for non-primitive values that are equal by value but have different pointers
 *
 * @param input1
 * @param input2
 * @param {string} mismatchMessage
 * @returns {string|undefined} The error message(s) generated by the validation
 */
export function requireMatch(input1: unknown, input2: unknown, mismatchMessage: string): string {
	return input1 === input2 ? undefined : mismatchMessage
}